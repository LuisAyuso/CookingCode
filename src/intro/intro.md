# Introduction
This code pretends to be language agnostic, and to enforce that, several different languages will be used to illustrate concepts. Far from confusing you, this is meant to highlight the most important tools that need to be considered. Then, learning the specific details of any given technology is just a matter of typing the right questions in your favorite search engine.

## Why cooking?

Some day I realized that every time I explained something about programming, I always illustrate it with cooking examples. I believe than cooking and programming have many characteristics in common, but (over any other positive trait) I like cooking examples because anyone can relate to them. You do not need to be a Michelin cook to know what is an egg or a pan. Everyone is familiar with the basic steps in the kitchen, and once we move into more complicated dishes, we introduce more complexity in the form of kitchen staff, new tools and more sophisticated ingredients. Just like programming... You will see!

## What is programming?

Most people jumps into programming for many reasons, and (at some degree all of them) are valid. Nevertheless I would like to start by describing what programming can do for you, before we can find out what can you do for programming.

You may have hear about "solving"problems by using computers, and this is just plain wrong. We solve problems by applying some analytical method some guy (much more smarter than me) made up. We may even solve problems by pushing a brute force try-and-error approach over all the possible answers. Programming is the art of automatizing, getting those ideas and put them together into an automatic process that can be executed by a machine, hopefully with minimal human intervention.

To achieve this objective, a programmer needs to develop some skills which are common to every language, environment or problem we want to solve. That skills set requires us to learn how to Decompose, to Abstract, and Orchestrate processes from any nature.

### Decompose:

To be able to decompose into steps, and structures the process we work on. Where steps are the operations we need to execute or How to do and When, while the structures mean on What are we going to do something.

This skill can be leaned and trained. Knowledge about the problem we work on can solve to decompose, as well as understanding the environment we work on. Learning about data structures and their properties may help us to choose the right tool for the job.

### Abstract:

Sometimes, usually during Christmas dinners, someone states: Leonardo da Vinci was the last man to know about everything!. Although they may be right, it is pretty complicated (and totally unnecessary) to track down every detail of your program, as it is complicated nowadays to fully understand every phenomena in the universe. The amount of fields of human knowledge is huge! And so it is the amount of fields that contributed to nowadays computing systems.

Computers are vast, layered and complex systems. Many brilliant minds have been working hard to put together little pieces. Pieces which later on have been used by any other mind (brilliant or not) as building blocks of the next layer. A programmer needs to learn to abstract himself from the underlying systems, choosing when to pay attention to a given component of the system. Programmers develop the skill to ignore everything what is out of the current scope.

It is Just like any other process of the real world! After all, it is very unlikely that you hunt, butcher, and cook all together your own food. Although you can always go that way if you have the time.

### Orchestrate:

Now that we have successfully understood the nature of the process we want to automatize, and what is in the reach of our effort is time to put some order and get the job done. We need to cope with those steps we identified by decomposing the problem, and tailor them in time so we they are executed in the correct order. Programmers need to understand timing, since in most of cases the problem is not what to do but when.

Most certainly the more complicated skill to grow; as we program some code and it grows fat in number of lines, the visibility we have over the big picture turns blurry and partial. This situation turns even more chaotic when more than one programmer has contributed, and it turns desperate if you have no one who to ask.

Orchestrating your processes in a way that they do not interfere with each other, is a must. The correctness of your solution depends on it. Orchestrating your processes in a way that they do not interfere with anyone else processes, is a desirable skill which will sometimes make you think if your are the only one sane person in the world.

### Enjoy:

Yes, enjoy. Because code can be dirty and ugly, and the process you are working on could not be the most exciting task to do. Even in this scenarios, programming is challenging, and you can always rely in the fact that there is a different way to do (most of the cases there will be a better way to go). Measuring yourself and accepting the challenge will make you a better programmer every day, in the same manner sports do.
